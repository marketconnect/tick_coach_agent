diff --git a/agents/message_handler.py b/agents/message_handler.py
index a5d3e02..2659e41 100644
--- a/agents/message_handler.py
+++ b/agents/message_handler.py
@@ -10,6 +10,7 @@
 
 
 from .prompts import RESEARCH_INSTRUCTIONS, GOAL_CLARIFIER_SUBAGENT_DESCRIPTION, GOAL_CLARIFIER_SUBAGENT
+from .utils import send_telegram_error_notification
 from .ydb_checkpointer import YDBCheckpointer
 
 log = logging.getLogger(__name__)
@@ -279,21 +280,33 @@
                 "type": "clarifying_question",
                 "payload": e.questions
             }
-        except GraphRecursionError:
-             logging.error(f"–ú–æ–¥–µ–ª—å {model.model_name} –≤–æ—à–ª–∞ –≤ —Ü–∏–∫–ª. –ü—Ä–æ–±—É–µ–º —Å–ª–µ–¥—É—é—â—É—é –º–æ–¥–µ–ª—å.")
+        except GraphRecursionError as e:
+             logging.error(f"–ú–æ–¥–µ–ª—å {model.model_name} –≤–æ—à–ª–∞ –≤ —Ü–∏–∫–ª. –ü—Ä–æ–±—É–µ–º —Å–ª–µ–¥—É—é—â—É—é –º–æ–¥–µ–ª—å.")
+             send_telegram_error_notification(client_id, model.model_name, f"GraphRecursionError: {e}")
              continue
         except APIStatusError as e:
             if 400 <= e.status_code < 600:
                 logging.error(f"–ú–æ–¥–µ–ª—å {model.model_name} –∑–∞–≤–µ—Ä—à–∏–ª–∞—Å—å —Å –æ—à–∏–±–∫–æ–π HTTP {e.status_code}. –ü—Ä–æ–±—É–µ–º —Å–ª–µ–¥—É—é—â—É—é –º–æ–¥–µ–ª—å.", exc_info=True)
+                send_telegram_error_notification(client_id, model.model_name, f"APIStatusError: {e}")
                 continue
         except (httpx.ProxyError, APIConnectionError) as e:
             logging.error(f"–°–µ—Ç–µ–≤–∞—è –æ—à–∏–±–∫–∞/–ø—Ä–æ–∫—Å–∏ –¥–ª—è –º–æ–¥–µ–ª–∏ {model.model_name}. –ü—ã—Ç–∞–µ–º—Å—è –±–µ–∑ –ø—Ä–æ–∫—Å–∏.", exc_info=True)
+            send_telegram_error_notification(client_id, model.model_name, f"{type(e).__name__}: {e}")
             try:
                 model_no_proxy = rebuild_model_without_proxy(model)
                 graph = build_graph(model_no_proxy)
                 final_state = graph.invoke(graph_input, thread_config)
                 messages = final_state["messages"]
                 xml_payload = get_last_task_xml(messages)
                 if xml_payload:
                     is_valid = validate_form_xml(xml_payload)
                     if is_valid:
                         return {
                             "type": "clarifying_question",
                             "payload": xml_payload
                         }
                     fix_instruction = "XML –∏–∑ –ø–æ–¥–∞–≥–µ–Ω—Ç–∞ ask_clarifying_questions –Ω–µ —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É–µ—Ç —Å—Ö–µ–º–µ Form.xml. –ü–µ—Ä–µ—Å–æ–∑–¥–∞–π –≤–∞–ª–∏–¥–Ω—ã–π XML —Å—Ç—Ä–æ–≥–æ –ø–æ —Å—Ö–µ–º–µ –∏ –≤—ã–≤–µ–¥–∏ —Ç–æ–ª—å–∫–æ XML."
                     retry_state = graph.invoke({"messages": [HumanMessage(content=fix_instruction)]}, thread_config)
                     retry_messages = retry_state["messages"]
                     retry_xml = get_last_task_xml(retry_messages)
                     if retry_xml and validate_form_xml(retry_xml):
                         return {
                             "type": "clarifying_question",
                             "payload": retry_xml
                         }
                     return {
                         "type": "error",
                         "payload": "XML –∏–∑ –ø–æ–¥–∞–≥–µ–Ω—Ç–∞ ask_clarifying_questions –Ω–µ –≤–∞–ª–∏–¥–µ–Ω –ø–æ —Å—Ö–µ–º–µ Form.xml. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."
                     }
                 last_message = messages[-1]
                 return {
                     "type": "final_answer",
                     "payload": last_message.content
                 }
             except Exception as e2:
                 logging.error(f"–ü–æ–≤—Ç–æ—Ä –±–µ–∑ –ø—Ä–æ–∫—Å–∏ –¥–ª—è –º–æ–¥–µ–ª–∏ {model.model_name} –∑–∞–≤–µ—Ä—à–∏–ª—Å—è –æ—à–∏–±–∫–æ–π.", exc_info=True)
+                send_telegram_error_notification(client_id, model.model_name, f"Retry failed: {e2}")
                 continue
         except Exception as e:
             logging.error(f"–ü—Ä–æ–∏–∑–æ—à–ª–∞ –Ω–µ–ø—Ä–µ–¥–≤–∏–¥–µ–Ω–Ω–∞—è –æ—à–∏–±–∫–∞ —Å –º–æ–¥–µ–ª—å—é {model.model_name}. –ü—Ä–æ–±—É–µ–º —Å–ª–µ–¥—É—é—â—É—é –º–æ–¥–µ–ª—å.", exc_info=True)
+            send_telegram_error_notification(client_id, model.model_name, f"Unexpected error: {e}")
             continue
         
     log.error(f"All models failed for client_id: {client_id}")
+    send_telegram_error_notification(client_id, "N/A", "All models failed.")
     return {
         "type": "error",
         "payload": "–ù–µ —É–¥–∞–ª–æ—Å—å –ø–æ–ª—É—á–∏—Ç—å –æ—Ç–≤–µ—Ç –Ω–∏ –æ—Ç –æ–¥–Ω–æ–π –∏–∑ –¥–æ—Å—Ç—É–ø–Ω—ã—Ö –º–æ–¥–µ–ª–µ–π."
diff --git a/agents/utils.py b/agents/utils.py
new file mode 100644
index 0000000..8ec76d3
--- /dev/null
+++ b/agents/utils.py
@@ -0,0 +1,41 @@
+import os
+import logging
+import httpx
+
+log = logging.getLogger(__name__)
+
+TELEGRAM_BOT_TOKEN = os.getenv("TELEGRAM_BOT_TOKEN")
+TELEGRAM_CHAT_ID = os.getenv("TELEGRAM_CHAT_ID")
+SERVICE_NAME = "tick-coach-agent"
+
+def send_telegram_error_notification(client_id: str, model_name: str, error_message: str):
+    """
+    Sends a formatted error message to a Telegram chat.
+    Failures are logged and suppressed.
+    """
+    if not TELEGRAM_BOT_TOKEN or not TELEGRAM_CHAT_ID:
+        log.warning("Telegram notification credentials not set. Skipping notification.")
+        return
+
+    message = (
+        f"üö® **Error in {SERVICE_NAME}** üö®\n\n"
+        f"**Client ID:** `{client_id}`\n"
+        f"**Model Name:** `{model_name}`\n\n"
+        f"**Error Details:**\n"
+        f"```\n{error_message}\n```"
+    )
+
+    url = f"https://api.telegram.org/bot{TELEGRAM_BOT_TOKEN}/sendMessage"
+    payload = {
+        "chat_id": TELEGRAM_CHAT_ID,
+        "text": message,
+        "parse_mode": "Markdown"
+    }
+
+    try:
+        # Use a separate, simple httpx client for notifications to avoid proxy issues if any.
+        with httpx.Client(timeout=10.0) as client:
+            response = client.post(url, json=payload)
+            response.raise_for_status()
+    except Exception as e:
+        log.error(f"Failed to send Telegram error notification: {e}", exc_info=True)
diff --git a/index.py b/index.py
index e833215..667d716 100644
--- a/index.py
+++ b/index.py
@@ -1,5 +1,6 @@
 import json, base64, logging, sys
 from agents.message_handler import process_user_message
+from agents.utils import send_telegram_error_notification
 
 # --- BEGIN LangGraph compatibility shim (must be first) ---
 import sys, types
@@ -79,14 +80,24 @@
             "headers": {"Content-Type": "application/json; charset=utf-8"},
             "body": response_body,
         }
-    except json.JSONDecodeError:
-        logging.error(f"Failed to parse JSON from body: {body_str}")
+    except json.JSONDecodeError as e:
+        logging.error(f"Failed to parse JSON from body: {body_str}", exc_info=True)
+        send_telegram_error_notification(
+            client_id="unknown",
+            model_name="N/A",
+            error_message=f"JSONDecodeError: {e}\nBody: {body_str}"
+        )
         return {"statusCode": 400, "body": "Invalid JSON format."}
     except Exception as e:
         # client_id might not be defined if JSON parsing fails, so log cautiously.
         client_id_for_log = locals().get("client_id", "unknown")
         logging.error(f"Unhandled error during message processing for clientId '{client_id_for_log}'", exc_info=True)
         error_response = {"type": "error", "payload": "An internal error occurred."}
+        send_telegram_error_notification(
+            client_id=client_id_for_log,
+            model_name="N/A",
+            error_message=f"Unhandled error in index.py: {e}"
+        )
         return {
             "statusCode": 500,
             "headers": {"Content-Type": "application/json; charset=utf-8"},